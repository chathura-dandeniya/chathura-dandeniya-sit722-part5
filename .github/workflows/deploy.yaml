# 
# GitHub Actions workflow.
#
# Automatically deploys the Node.js microservice to Kubernetes on push to any branch. 
# For real use you might want to restrict this to the "prod" branch.
#

name: Deploy Library microservice Part 5

permissions:
  id-token: write
  contents: read

on:
  #
  # Deploys the microservice on push to the main branch of this code repository.
  #
  push: 
    branches:
      - main
    
  workflow_dispatch:

jobs:

  deploy:
    runs-on: ubuntu-latest
    
    env:
      #VERSION: ${{ github.sha }}
      #CONTAINER_REGISTRY: ${{ secrets.CONTAINER_REGISTRY }}
      #REGISTRY_UN: ${{ secrets.REGISTRY_UN }}
      #REGISTRY_PW: ${{ secrets.REGISTRY_PW  }}
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      #KUBE_CONFIG: ${{ secrets.KUBE_CONFIG  }}

    steps:
      
      # Checks-out your repository under $GITHUB_WORKSPACE.
      - uses: actions/checkout@v3

      - name: Debug Environment Variables
        run: |
          echo "ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}"
          echo "ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}"
          echo "ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}"
          echo "ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}"

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}


      # Specify the version of Terraform to use
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: latest

      - name: Set execute permissions
        run: chmod +x ./scripts/*.sh
      
      # Run Terraform Init, Plan, and Apply to create infrastructure and capture outputs
      - name: Terraform Init
        run: terraform init

      #- name: Terraform Plan
      #  run: terraform plan

      - name: Terraform Apply
        run: terraform apply -auto-approve

      - name: Retrieve AKS credentials
        run: |
          az aks get-credentials --resource-group deakinuni --name librarypart05 --overwrite-existing
          cat ~/.kube/config | base64 | tr -d '\n' > kubeconfig.txt

      - name: Set KUBE_CONFIG environment variable
        run: |
          echo "KUBE_CONFIG=$(cat kubeconfig.txt)" >> $GITHUB_ENV

      - name: Verify Kubernetes Cluster Access
        run: |
          kubectl cluster-info

      # Capture Terraform Outputs for registry details (username, password, registry URL)
      - name: Capture Terraform Outputs
        id: tf_output
        run: |
          echo "::set-output name=registry_username::$(terraform output -raw registry_username)"
          echo "::set-output name=registry_password::$(terraform output -raw registry_password)"
          echo "::set-output name=registry_login_server::$(terraform output -raw registry_login_server)"

      # Set environment variables for Container Registry details dynamically
      - name: Set Container Registry Environment Variables
        run: |
          echo "Setting container registry environment variables..."
          echo "CONTAINER_REGISTRY=${{ steps.tf_output.outputs.registry_login_server }}" >> $GITHUB_ENV
          echo "REGISTRY_UN=${{ steps.tf_output.outputs.registry_username }}" >> $GITHUB_ENV
          echo "REGISTRY_PW=${{ steps.tf_output.outputs.registry_password }}" >> $GITHUB_ENV

      
     #  Builds the Docker image.
      
      - name: Build
        run: ./scripts/build-image.sh

      
     #  Publishes the Docker image to the container registry.
      
      - name: Publish
        run: ./scripts/push-image.sh

      
      # Installs Kubectl and connects it to the cluster.
      #
      # https://github.com/marketplace/actions/kubernetes-cli-kubectl
      #
      - name: Install kubectl and configure cluster access
        uses: tale/kubectl-action@v1
        with:
          base64-kube-config: ${{ secrets.KUBE_CONFIG }}
          kubectl-version: v1.30.2

      # Verify that the Kubernetes API is accessible.
      - name: Check Kubernetes cluster status
        run: kubectl cluster-info
      
      #
      # Expands the configuration template and deploys the microservice.
      #
      - name: Deploy
        run: ./scripts/deploy.sh

      #- name: Delete
      #  run: ./scripts/delete.sh